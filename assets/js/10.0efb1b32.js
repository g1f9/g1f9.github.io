(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{288:function(a,t,r){"use strict";r.r(t);var e=r(38),v=Object(e.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"性能优化类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#性能优化类","aria-hidden":"true"}},[a._v("#")]),a._v(" 性能优化类")]),a._v(" "),r("h2",{attrs:{id:"性能测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#性能测试","aria-hidden":"true"}},[a._v("#")]),a._v(" 性能测试")]),a._v(" "),r("h2",{attrs:{id:"性能优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#性能优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 性能优化")]),a._v(" "),r("h3",{attrs:{id:"网络资源加载优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络资源加载优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 网络资源加载优化")]),a._v(" "),r("ol",[r("li",[a._v("减少 http 请求次数。懒加载，合并雪碧图，css 文件，js，CDN Combo，小图标转 base64 内嵌等")]),a._v(" "),r("li",[a._v("减小 HTTP 请求大小。开启 gzip，压缩 js，css 文件，启用 http2，Cookie 隔离")]),a._v(" "),r("li",[a._v("外链 CSS，js 文件，有利于缓存改动较小 css，js 文件，减少网络请求")]),a._v(" "),r("li",[a._v("避免空的 src，href 等，依然会进行网络请求，直到失败阻塞其他网络请求")]),a._v(" "),r("li",[a._v("使用 Cache-Control，ETag，Last-Modified 进行缓存")]),a._v(" "),r("li",[a._v("静态资源分域存在，增加并行下载数")]),a._v(" "),r("li",[a._v("CDN 加速")]),a._v(" "),r("li",[a._v("缓存 Ajax 请求")]),a._v(" "),r("li",[a._v("异步加载 JavaScript 资源")]),a._v(" "),r("li",[a._v("DNS 预解析，同 prefetch 属性")]),a._v(" "),r("li",[a._v("单张图片不超过 30 KB")])]),a._v(" "),r("h3",{attrs:{id:"页面渲染类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染类","aria-hidden":"true"}},[a._v("#")]),a._v(" 页面渲染类")]),a._v(" "),r("ol",[r("li",[a._v("置顶 CSS 资源，置尾 js 资源，是为了让 js 不阻塞页面渲染")]),a._v(" "),r("li",[a._v("减少 DOM 的深度")]),a._v(" "),r("li",[a._v("避免使用 table 和 iframe 表情，table 是全部渲染完成，一次绘制，因此在长表格时很耗性能")])]),a._v(" "),r("h4",{attrs:{id:"回流和重绘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回流和重绘","aria-hidden":"true"}},[a._v("#")]),a._v(" 回流和重绘")]),a._v(" "),r("p",[a._v("常见重绘场景")]),a._v(" "),r("ol",[r("li",[a._v("更改 DOM 的几何属性，如 width，height，padding，margin 等。为耗时操作")]),a._v(" "),r("li",[a._v("获取即时属性。offsetTop，scrollTop，clientTop，getComputedStyle 等")]),a._v(" "),r("li",[a._v("更改 DOM 结构，如移动节点位置等")])]),a._v(" "),r("p",[a._v("避免回流，减少重绘，核心思想与优化 DOM 一致")]),a._v(" "),r("ol",[r("li",[a._v("缓存样式改动，把改动用一个 js 对象缓存起来，再一起应用")]),a._v(" "),r("li",[a._v("用 class 合并多个样式的改动，替代一条条 style 改动")]),a._v(" "),r("li",[a._v("离线 DOM，使用 display:none，把 DOM 离线，经过频繁的改动后，再用 display:block 重新渲染")])]),a._v(" "),r("h4",{attrs:{id:"dom-为什么慢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dom-为什么慢","aria-hidden":"true"}},[a._v("#")]),a._v(" DOM 为什么慢")]),a._v(" "),r("ol",[r("li",[a._v("修改 DOM 需要 js 引擎和渲染引擎进行通信，需要一定通信成本")]),a._v(" "),r("li",[a._v("修改 DOM 时触发的回流重绘同样导致渲染速度变慢\n"),r("ol",[r("li",[a._v("回流即 DOM 几何属性的变化，如修改元素宽高，隐藏元素等，浏览器需要重新计算元素的几何属性。因为在渲染树的布局（回流）阶段，浏览器时需要精密计算出每一个节点的位置，大小属性。反而言之，需要重新计算位置和大小，那么就回到了回流阶段")]),a._v(" "),r("li",[a._v("重绘。也就是对应浏览器渲染中的绘制图层阶段，把DOM 图层转换为像素点，如颜色，背景等")])])])]),a._v(" "),r("h4",{attrs:{id:"dom-优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dom-优化","aria-hidden":"true"}},[a._v("#")]),a._v(" DOM 优化")]),a._v(" "),r("ol",[r("li",[a._v("减少 DOM 操作次数，如要插入一百条记录，不能插一百次，而是先用 js 生成一百条相关文档，然后一次插入到 DOM 中")]),a._v(" "),r("li",[a._v("缓存 DOM 操作，使用 DOM Fragment 缓存 js 对于 DOM 节点的操作，比如在先把一百记录插到 DOM Fragment 中，在将 DOM Fragement 插入 DOM 中。又如如果一个元素进行了增删增操作，实际上只需要一次增操作，我使用 DOM Fragement 进行增删增之后，再进行更新。")]),a._v(" "),r("li",[a._v("异步更新策略。一个 Event-Loop 会经过。macro-task -> micro-task -> 渲染更新 -> 检查&& 执行 WebWoker。因此在异步更新的策略中，把更新任务放在 micro-task 里面可以最靠近渲染步骤，从而尽快地更新。而放在宏任务中，需要等下一轮的渲染")])]),a._v(" "),r("h3",{attrs:{id:"移动端常见优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#移动端常见优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 移动端常见优化")]),a._v(" "),r("ol",[r("li",[a._v("首屏数据提前请求")]),a._v(" "),r("li",[a._v("首屏按需加载，非首屏滚动加载，懒加载。首屏数据大小总共不超过 1MB")]),a._v(" "),r("li",[a._v("内联必备的 CSS 和 JavaScript")])]),a._v(" "),r("h3",{attrs:{id:"webpack-构建优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack-构建优化","aria-hidden":"true"}},[a._v("#")]),a._v(" webpack 构建优化")]),a._v(" "),r("p",[a._v("webpack 打包主要围绕着两个问题，一是构建速度的问题，而是打包体积的问题")]),a._v(" "),r("h3",{attrs:{id:"构建速度优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建速度优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 构建速度优化")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("启用缓存。如 babel 可以将转译结果缓存到文件系统")])]),a._v(" "),r("li",[r("p",[a._v("DllPlugin，借鉴了 windows 动态连接库的思想，把可以把第三方库打包到一个单独的文件中，只有依赖发生变化时才会重新打包，从而解决 CommonsChunkPlugin 每次构建都重新构建一次 vendor 的问题")])]),a._v(" "),r("li",[r("p",[a._v("happy pack 多线程打包")])])]),a._v(" "),r("h3",{attrs:{id:"构建体积优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建体积优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 构建体积优化")]),a._v(" "),r("ol",[r("li",[a._v("拆分资源。如 CommonsChunkPlugin 可以把公用的依赖打包到一个chunk，从而防止重复打包依赖。拆分资源也有体积缩小和按需加载")]),a._v(" "),r("li",[a._v("删除冗余代码。tree-shaking，可以在编译过程中删除在上下文中未引用到的代码，依赖于 ES6 的 import/export 静态结构特性。tree-shaking 仅进行标记，故也需要一个能够删除未引用代码的插件如 UglifyJSPlugin")]),a._v(" "),r("li",[a._v("按需加载。如 webpack import()，和 require.ensure 会在这个语句执行时创建一个入口端点，这个模块以及其子模块就会被单独打包到一个文件中。")])]),a._v(" "),r("h2",{attrs:{id:"图片优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图片优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 图片优化")]),a._v(" "),r("ol",[r("li",[a._v("jpg 有损失压缩，压缩比大，色彩丰富，使用于大图")]),a._v(" "),r("li",[a._v("png 无损压缩，色彩多，支持透明度，适用于边缘感强，带透明度的小图标")]),a._v(" "),r("li",[a._v("svg 优点是文件体积小，矢量图形，放大不失真，可编程，缺点是占用渲染成本，一定学习成本")]),a._v(" "),r("li",[a._v("Base64 和 CSS Sprites。Base64，是一种编码方式，通过把小图转 base64 格式，嵌入到 html 中，从而减少 http 请求次数，适用 2Kb 以下，不经常改变的小图标。CSS Sprites，把多个形状规则的小图标合成一张大图，通过 background-position 去定位图标，主要目的是为了减少 http 请求次数")]),a._v(" "),r("li",[a._v("webp。集有多种图片格式的优点于一身，支持色彩丰富，压缩比高，支持透明度，支持动态图片。缺点是兼容性差，仅谷歌的支持性好。可以在前端采用降级方案，如果不支持 webp 就降级成 jpg。如淘宝采用 xxx.jpg.webp 这种格式，在检测到不支持 webp 时，就去掉 .webp 从而去请求 jpg 格式")])]),a._v(" "),r("h2",{attrs:{id:"服务端渲染-ssr"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染-ssr","aria-hidden":"true"}},[a._v("#")]),a._v(" 服务端渲染 SSR")]),a._v(" "),r("p",[a._v("客户端渲染，即 dom 和 内容由客户端浏览器跑 js 生成。")]),a._v(" "),r("p",[a._v("服务端渲染，即服务器把需要的组件或页面渲染成 html 字符，然后返回给客户端，客户端拿到的就是直接可渲染然后可以呈现给用户的 html 内容，不需要再去为了生成 dom 再去跑一遍 js")]),a._v(" "),r("h3",{attrs:{id:"客户端渲染优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#客户端渲染优缺点","aria-hidden":"true"}},[a._v("#")]),a._v(" 客户端渲染优缺点")]),a._v(" "),r("p",[a._v("有利于减少服务器压力，充分利用浏览器资源。缺点是不利于 SEO 优化，不利于首屏的加载。")]),a._v(" "),r("h3",{attrs:{id:"服务端渲染的优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染的优缺点","aria-hidden":"true"}},[a._v("#")]),a._v(" 服务端渲染的优缺点")]),a._v(" "),r("p",[a._v("有利于 SEO，首屏加载。缺点是大大增大了服务端的压力")])])},[],!1,null,null,null);t.default=v.exports}}]);