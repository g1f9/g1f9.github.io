<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Wepy | g1f9</title>
    <meta name="description" content="记录">
    
    
    <link rel="preload" href="/assets/css/0.styles.74efe9eb.css" as="style"><link rel="preload" href="/assets/js/app.ccbd119b.js" as="script"><link rel="preload" href="/assets/js/2.7f0dc0b6.js" as="script"><link rel="preload" href="/assets/js/23.a3e9e8f8.js" as="script"><link rel="prefetch" href="/assets/js/10.0efb1b32.js"><link rel="prefetch" href="/assets/js/11.c90cd893.js"><link rel="prefetch" href="/assets/js/12.972c5b8f.js"><link rel="prefetch" href="/assets/js/13.2badb955.js"><link rel="prefetch" href="/assets/js/14.b0df3f85.js"><link rel="prefetch" href="/assets/js/15.5d827cb8.js"><link rel="prefetch" href="/assets/js/16.c6f4a891.js"><link rel="prefetch" href="/assets/js/17.27916a81.js"><link rel="prefetch" href="/assets/js/18.11f598b4.js"><link rel="prefetch" href="/assets/js/19.73dae33a.js"><link rel="prefetch" href="/assets/js/20.15c25eec.js"><link rel="prefetch" href="/assets/js/21.a870acbb.js"><link rel="prefetch" href="/assets/js/22.ca308be0.js"><link rel="prefetch" href="/assets/js/24.b6bb07e2.js"><link rel="prefetch" href="/assets/js/25.0359653c.js"><link rel="prefetch" href="/assets/js/26.a09d11a6.js"><link rel="prefetch" href="/assets/js/27.9a34aab8.js"><link rel="prefetch" href="/assets/js/28.1262566c.js"><link rel="prefetch" href="/assets/js/29.3eb81e77.js"><link rel="prefetch" href="/assets/js/3.d46bcc0e.js"><link rel="prefetch" href="/assets/js/30.faa6dd9c.js"><link rel="prefetch" href="/assets/js/31.3b40da97.js"><link rel="prefetch" href="/assets/js/32.eec2213b.js"><link rel="prefetch" href="/assets/js/33.14287cf7.js"><link rel="prefetch" href="/assets/js/4.570df549.js"><link rel="prefetch" href="/assets/js/5.482ae8ae.js"><link rel="prefetch" href="/assets/js/6.32b63521.js"><link rel="prefetch" href="/assets/js/7.5ad4d5a2.js"><link rel="prefetch" href="/assets/js/8.890852ad.js"><link rel="prefetch" href="/assets/js/9.4be23048.js">
    <link rel="stylesheet" href="/assets/css/0.styles.74efe9eb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">g1f9</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/resource.html" class="nav-link">资源收集</a></li><li class="dropdown-item"><!----> <a href="/frontend/basics/" class="nav-link">基础阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/read-code/" class="nav-link router-link-active">源码阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/advanced/" class="nav-link">扩展阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/note/" class="nav-link">笔记</a></li><li class="dropdown-item"><!----> <a href="/frontend/source/" class="nav-link">资源收集</a></li></ul></div></div><div class="nav-item"><a href="/tools/" class="nav-link">工具</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/resource.html" class="nav-link">资源收集</a></li><li class="dropdown-item"><!----> <a href="/frontend/basics/" class="nav-link">基础阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/read-code/" class="nav-link router-link-active">源码阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/advanced/" class="nav-link">扩展阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/note/" class="nav-link">笔记</a></li><li class="dropdown-item"><!----> <a href="/frontend/source/" class="nav-link">资源收集</a></li></ul></div></div><div class="nav-item"><a href="/tools/" class="nav-link">工具</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Wepy</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/read-code/wepy.html#安装" class="sidebar-link">安装</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/frontend/read-code/wepy.html#错误处理" class="sidebar-link">错误处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/frontend/read-code/wepy.html#watch-文件" class="sidebar-link">Watch 文件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/frontend/read-code/wepy.html#组件" class="sidebar-link">组件</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="wepy"><a href="#wepy" aria-hidden="true" class="header-anchor">#</a> Wepy</h1> <h2 id="安装"><a href="#安装" aria-hidden="true" class="header-anchor">#</a> 安装</h2> <ol><li>要运行 wepy 项目必须安装它的 cli。项目的编译逻辑都写在了 cli 里面。而 wepy-cli 给了只是用来初始化项目的错觉，导致新的环境在不需要初始化项目的情况下常常忘了安装 cli 而导致项目跑不起来，将 cli 作为项目依赖又感觉cli的项目初始化功能很冗余。。。。。。。。。。。。</li></ol> <h2 id="错误处理"><a href="#错误处理" aria-hidden="true" class="header-anchor">#</a> 错误处理</h2> <ol><li>wepy 即使引用了不存在的组件也会继续编译。导致后续的 log 把前面的错误掩盖了，从而忽略的报错。</li> <li>在 wxml 区域使用了不存在的组件的时候也不会有错误提示，而是当成自定义标签直接渲染。</li> <li>组件中的 props 的初始值不满足检测条件的话，会直接忽略这个 props，注意即使你后续更改传入的值符合检测条件，这个 props 也不会再生效，所以注意 props 的初始值。</li> <li>data 中存在相同 props 的 key 时，也不会报错，只会忽略传递进来的 props。</li> <li>依赖检测只存在编译阶段，不存在于运行阶段，也不有错误提示。因此注意不要频繁更改文件位置</li> <li>总结一句话，wepy 基本吞了错误，没有达到预期效果只能仔细阅读文档和检查代码了。</li> <li>wepy 编译阶段识别模块否为一个组件的方式并非是根据继承的类来判断，而是在你的组件是否放在 components 目录下，如果你的文件路径包含 components 目录，那么就认为是一个组件。所以组件尽量放在 components，wepy 会针对 component 做一些处理，不然会出现什么错误也不清楚。</li></ol> <h2 id="watch-文件"><a href="#watch-文件" aria-hidden="true" class="header-anchor">#</a> Watch 文件</h2> <p>小程序的 watch 只是监听所有文件的改动，在 src 里面找出所有依赖当前的文件的文件。寻中依赖的过程即读取 src 里面所有的文件，用正则 import xxx from 'xxx'去匹配所有文件内容，得到文件的路径解析后和当前更改的文件路径进行比较，若相同则说明这个文件依赖于当前更改的文件。并且检测到依赖的文件路径里面包含 components 的话，还有进一步递归寻找依赖。并且最为关键的一点</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">return</span> _util2<span class="token punctuation">.</span>default<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span>parents<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;components&quot;</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>查找完所有依赖，它会排除掉路径里面含有 components 的文件。这意味着当组件依赖于组件时，被依赖的组件的更新不会触发依赖组件的重新编译。这个步骤会导致一些问题，如当被依赖组件位置移动时，依赖组件没有重新编译，自然不会检测到错误，也不会有错误提示，这时的后果无非是把你的自定义组件当前自定义标签来渲染。有时也可能导致样式不生效问题（这个遇到过，不太清楚是否时这个问题导致的）。</p> <h2 id="组件"><a href="#组件" aria-hidden="true" class="header-anchor">#</a> 组件</h2> <ol><li>wepy 中的组件都是静态组件，并且是以组件的 id 作为唯一标识符。（官方说法）这是由于wepy 的数据访问机制导致的。编译阶段会把组件的 wxml 递归查找加入到非 componets 的容器中，一般来说是 page，然后通过组件 id 拼接成 path 来访问数据。这种将嵌套的组件结构拍平，拼接 path 来访问数据导致我们在使用同一组件，只能用不同的 id 形成不同的 path 来访问不同的数据。组件的构造函数是有生成不同的 data，computed 的，导致数据混乱还是因为在编译阶段处理得过于简单。</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code> components <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token comment">//为两个相同组件的不同实例分配不同的组件ID，从而避免数据同步变化的问题</span>
            child<span class="token punctuation">:</span> Child<span class="token punctuation">,</span>
            anotherchild<span class="token punctuation">:</span> Child
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-vue extra-class"><pre class="language-vue"><code>components={
	comp:Comp,
	comp2:Comp
}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comp</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comp</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp</span><span class="token punctuation">&gt;</span></span>

	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comp2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp2</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

// 编译后
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!--
		很显然访问数据的方式是通过拼接组件 id 形成一条 path 来访问。如果想访问不同 data 只能使用不同 id，形成不同的 path
	--&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name"><span class="token namespace">wx:</span>if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>{{$comp$isShow}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name"><span class="token namespace">wx:</span>if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>{{$comp$isShow}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name"><span class="token namespace">wx:</span>if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>{{$comp2$isShow}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><ol start="2"><li>Repeat 循环组件</li></ol> <p>wepy 在编译阶段会忽略掉组件的 wx:for。因此要循环一个组件必须使用它 repeat 标签。注意，即使你使用了 repeat 标签循环组件，组件的数据仍染是通过 path 来访问的，因此循环的组件仍然访问相同的 data。repeat 标签无非在外部包裹了一层 wx:for。因此不想用 repeat 的话，可以尝试</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>block</span> <span class="token attr-name"><span class="token namespace">wx:</span>for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>{{[1,2,3]}}<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">wx:</span>key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>key<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comp</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>block</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>效果基本相似</p> <ol start="3"><li>事件机制</li></ol> <p>wepy 是以组件树的形式来组织，app 为根节点，每个组件会有 $com 存储子组件实例，以及 $parent 属性来指向父组件实例，由此组织起一颗组件树。事件的基本机制很简单，父组件在 $on 的时候，将事件名以及处理事件相关函数信息存在自己的 events 里面。子组件在 emit 的时候从父组件 this.$parent.$events 或者 events 里取得对应的事件的处理函数，然后进行调用。</p> <p>自定义事件有两个注意事项</p> <ol><li>wepy 的组件自定义事件必须要用 .user 修饰符来修饰，否者不会存储到 $events 里面，也就无法捕获。这是与 vue 不同的。</li> <li>在 wxml 用@xxx.user 注册的事件和使用组件的 events 注册的并不一样。用修饰符注册的存储在 $events 里面，存储在带有组件名的空间下。因此其他子组件的即使发射相同事件也无法触发对应的函数。而有 events 包含组件名， 则是任意子组件只要有相同的事件名就能触发，并且还会递归触发父组件的相同事件名。这一点是由 emit 的逻辑决定的。</li></ol> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">@do-some.user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handlerDo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span>
// $events 大概这样 
parent.$events ={
	'child':{
		'v-on:do-some':'handleDo'
	}
}

// events 即不带组件名存储
parent.events={
	'do-a':''
}

</code></pre></div><ol start="4"><li>props 传值</li></ol> <p>子组件的 props 字段是由开发者进行定义，主要定义了接收什么类型的值。父组件的 $props 则是定义了哪个子组件怎么引用了父组件的哪些值。如下所示</p> <div class="language- extra-class"><pre class="language-text"><code>//child
props = {
	'user':{
		type:Object
	}
}
//parent
&lt;child :user.sync=&quot;user&quot;&gt;&lt;/child&gt;
parent.$props = {
	'child':{
		'user.sync':'user'
	}
}
</code></pre></div><p>子组件在初始化的时候，会根据自己的 props 配置从父组件取值。取值的前会进行校验，校验成功的会存放在$mappingProps 中存放映射。取值成功的话，data 里面又没有这个props 的 key 的话，就会把数据设置到 data 里面。因此其实 data 和 props 是混在一起的，只是来源不一样而已，而在设置 props 会有许多检测，任意一个不通过的话都拿不到 props 值，当然也不会报错，甚至不知道为什么错。</p> <p>子组件的 props 和父组件 data 的响应式逻辑写在 $digest 方法中。暴露的 $apply 也主要是调用 $digest 方法，在 digest 方法中，会对 computed，watch 进行检测和调用，也会更新子组件 props 值。重点在于更新 props 值的时会去 $mappingProps 里面取映射，由初始化时检测不通过，没有在 mappingProps 里面存映射，自然无法更新。后续就算父组件的数据符合条件了，也无法更新子组件的数据了。</p> <h1 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h1> <p>wepy 使用起来体验很差，针对体验差的部分对其代码进行下思考，大致得出以上结论。第一次使用这个框架，可能还是有些错误的地方，欢迎补充和纠正。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ccbd119b.js" defer></script><script src="/assets/js/2.7f0dc0b6.js" defer></script><script src="/assets/js/23.a3e9e8f8.js" defer></script>
  </body>
</html>
