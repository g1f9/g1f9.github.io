<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Babel | g1f9</title>
    <meta name="description" content="记录">
    
    
    <link rel="preload" href="/assets/css/0.styles.74efe9eb.css" as="style"><link rel="preload" href="/assets/js/app.ccbd119b.js" as="script"><link rel="preload" href="/assets/js/2.7f0dc0b6.js" as="script"><link rel="preload" href="/assets/js/8.890852ad.js" as="script"><link rel="prefetch" href="/assets/js/10.0efb1b32.js"><link rel="prefetch" href="/assets/js/11.c90cd893.js"><link rel="prefetch" href="/assets/js/12.972c5b8f.js"><link rel="prefetch" href="/assets/js/13.2badb955.js"><link rel="prefetch" href="/assets/js/14.b0df3f85.js"><link rel="prefetch" href="/assets/js/15.5d827cb8.js"><link rel="prefetch" href="/assets/js/16.c6f4a891.js"><link rel="prefetch" href="/assets/js/17.27916a81.js"><link rel="prefetch" href="/assets/js/18.11f598b4.js"><link rel="prefetch" href="/assets/js/19.73dae33a.js"><link rel="prefetch" href="/assets/js/20.15c25eec.js"><link rel="prefetch" href="/assets/js/21.a870acbb.js"><link rel="prefetch" href="/assets/js/22.ca308be0.js"><link rel="prefetch" href="/assets/js/23.a3e9e8f8.js"><link rel="prefetch" href="/assets/js/24.b6bb07e2.js"><link rel="prefetch" href="/assets/js/25.0359653c.js"><link rel="prefetch" href="/assets/js/26.a09d11a6.js"><link rel="prefetch" href="/assets/js/27.9a34aab8.js"><link rel="prefetch" href="/assets/js/28.1262566c.js"><link rel="prefetch" href="/assets/js/29.3eb81e77.js"><link rel="prefetch" href="/assets/js/3.d46bcc0e.js"><link rel="prefetch" href="/assets/js/30.faa6dd9c.js"><link rel="prefetch" href="/assets/js/31.3b40da97.js"><link rel="prefetch" href="/assets/js/32.eec2213b.js"><link rel="prefetch" href="/assets/js/33.14287cf7.js"><link rel="prefetch" href="/assets/js/4.570df549.js"><link rel="prefetch" href="/assets/js/5.482ae8ae.js"><link rel="prefetch" href="/assets/js/6.32b63521.js"><link rel="prefetch" href="/assets/js/7.5ad4d5a2.js"><link rel="prefetch" href="/assets/js/9.4be23048.js">
    <link rel="stylesheet" href="/assets/css/0.styles.74efe9eb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">g1f9</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/resource.html" class="nav-link">资源收集</a></li><li class="dropdown-item"><!----> <a href="/frontend/basics/" class="nav-link">基础阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/read-code/" class="nav-link">源码阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/advanced/" class="nav-link router-link-active">扩展阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/note/" class="nav-link">笔记</a></li><li class="dropdown-item"><!----> <a href="/frontend/source/" class="nav-link">资源收集</a></li></ul></div></div><div class="nav-item"><a href="/tools/" class="nav-link">工具</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/resource.html" class="nav-link">资源收集</a></li><li class="dropdown-item"><!----> <a href="/frontend/basics/" class="nav-link">基础阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/read-code/" class="nav-link">源码阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/advanced/" class="nav-link router-link-active">扩展阅读</a></li><li class="dropdown-item"><!----> <a href="/frontend/note/" class="nav-link">笔记</a></li><li class="dropdown-item"><!----> <a href="/frontend/source/" class="nav-link">资源收集</a></li></ul></div></div><div class="nav-item"><a href="/tools/" class="nav-link">工具</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Babel</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/advanced/babel.html#概述" class="sidebar-link">概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced/babel.html#简单案例" class="sidebar-link">简单案例</a></li></ul></li><li><a href="/frontend/advanced/babel.html#babel-preset-env" class="sidebar-link">@babel/preset-env</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced/babel.html#browserlist-集成" class="sidebar-link">browserlist 集成</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced/babel.html#options-配置" class="sidebar-link">Options 配置</a></li></ul></li><li><a href="/frontend/advanced/babel.html#babel-plugin-transform-runtime" class="sidebar-link">@babel/plugin-transform-runtime</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced/babel.html#配置" class="sidebar-link">配置</a></li></ul></li><li><a href="/frontend/advanced/babel.html#babel-cli" class="sidebar-link">@babel/cli</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced/babel.html#用法" class="sidebar-link">用法</a></li></ul></li><li><a href="/frontend/advanced/babel.html#the-super-tiny-compiler" class="sidebar-link">the super tiny compiler</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/advanced/babel.html#parsing" class="sidebar-link">Parsing</a></li><li class="sidebar-sub-header"><a href="/frontend/advanced/babel.html#示例代码" class="sidebar-link">示例代码</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="babel"><a href="#babel" aria-hidden="true" class="header-anchor">#</a> Babel</h1> <h2 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h2> <blockquote><p>以下内容均基于 babel7。在 babel7中，插件名以 @babel 开头</p></blockquote> <p>Babel 是一个 JavaScript 编译器，工具链，主要用于将 ES6 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。babel 主要能做以下事情</p> <ol><li>语法转换</li> <li>polyfill。在目标环境中添加缺失的特性</li> <li>源码转换</li> <li>more</li></ol> <p>babel 核心不处理任何代码转换，它只负责将代码转换成 ast，然后将 ast 交给插件去处理。在不使用任何插件的情况下就相当于<code>(code)=&gt;code</code>。插件负责语法转换，并且一个插件只负责一类代码转换。例如 @babel/plugin-transform-arrow-functions 负责将箭头函数转换为普通函数，如果你加入了这个插件，编译过后的箭头函数就能输出为普通函数，如果不加入，那么箭头函数将会原样输出。默认不加任何插件的情况下，输出的代码就等于输入的代码。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">f</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token number">1</span>
<span class="token comment">//./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions</span>
<span class="token comment">//使用 @babel/plugin-transform-arrow-functions 转换后</span>
<span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment">// 可以看到箭头函数转了，但是 const 没转</span>
</code></pre></div><p>在上面的例子，使用箭头函数插件，但是他并没有转换 <code>const</code>，那么为了转换 const 我们就需要引入另外一个插件。因此为了完整地将 es6 转换成对应 es5 代码需要往配置中加入大量的插件，为了避免这样重复的工作。引入了 preset，即一组预设的插件，由预设来管理我们目标的插件集合。@babel/preset-env 可以根据我们配置的目标环境提供一组对应插件。</p> <div class="language-js extra-class"><pre class="language-js"><code>npm install <span class="token operator">--</span>save<span class="token operator">-</span>dev @babel<span class="token operator">/</span>preset<span class="token operator">-</span>env
<span class="token punctuation">.</span><span class="token operator">/</span>node_modules<span class="token operator">/</span><span class="token punctuation">.</span>bin<span class="token operator">/</span>babel src <span class="token operator">--</span>out<span class="token operator">-</span>dir lib <span class="token operator">--</span>presets<span class="token operator">=</span>@babel<span class="token operator">/</span>preset<span class="token operator">-</span>env
</code></pre></div><p>上述预设默认情况下支持所有最新的 JavaScript 特性。</p> <p>@babel/preset-env 也支持 polyfill，可以根据使用情况和目标环境自动引入对应的文件，传入 useBuiltIns，和对应的 corejs 参数即可。@babel-core+@babel/preset-env 已经能很好工作了，但是在编译过后的文件中，存在大量重复定义的帮助方法，会影响最后的整体体积。为了进一步优化，引入 @babel/plugin-transform-runtime 这个插件。默认情况下这个插件可以把这些内联的帮助函数定义改成从 runtime/helpers 中引入。当然这个插件也不只这个功能。</p> <h3 id="简单案例"><a href="#简单案例" aria-hidden="true" class="header-anchor">#</a> 简单案例</h3> <p><code>yarn add @babel/cli @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</code></p> <p><code>yarn add core-js@3</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 项目根目录</span>
<span class="token comment">//.babelrc</span>
<span class="token punctuation">{</span>
  <span class="token string">&quot;presets&quot;</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;@babel/preset-env&quot;</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;useBuiltIns&quot;</span><span class="token punctuation">:</span><span class="token string">&quot;usage&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;corejs&quot;</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">&quot;plugins&quot;</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">//package.json</span>
<span class="token punctuation">{</span>
  <span class="token string">&quot;scripts&quot;</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
   <span class="token string">&quot;compile&quot;</span><span class="token punctuation">:</span><span class="token string">&quot;babel src --out-dir dist&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>npm run compile</code></p> <h2 id="babel-preset-env"><a href="#babel-preset-env" aria-hidden="true" class="header-anchor">#</a> @babel/preset-env</h2> <p>@babel/preset-env 是一个十分灵活的预设，它使我们能够使用最新 JS 语法特性，又避免需要我们去手动配置那些细微的语法转换，也支持根据对应的环境进行 polyfill（需要配置）。@babel/preset-env 的开源得益于众多的优秀的开源项目，例如 <a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener noreferrer">browserslist<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，<a href="https://github.com/kangax/compat-table" target="_blank" rel="noopener noreferrer">compat-table<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a href="https://github.com/Kilian/electron-to-chromium" target="_blank" rel="noopener noreferrer">electron-to-chromium<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，从这些开源项目获取数据，来获取对应目标环境的 JavaScript 语法特性，从而更好的进行语法转换和 polyfill。</p> <h3 id="browserlist-集成"><a href="#browserlist-集成" aria-hidden="true" class="header-anchor">#</a> browserlist 集成</h3> <p>对于浏览器或者基于 Electron 的项目，推荐使用一个 .browserlistrc 文件来指定目标环境，许多工具也使用了这个文件，例如 autoprefixer，stylelint，eslint-plugin-compact 等。若果没有配置 target 或者 ignoreBrowserlistConfig，那么 preset-env 就默认使用 browserlist 的源配置。</p> <h4 id="案例"><a href="#案例" aria-hidden="true" class="header-anchor">#</a> 案例</h4> <h5 id="browserslist"><a href="#browserslist" aria-hidden="true" class="header-anchor">#</a> browserslist</h5> <p>浏览器市场份额大于 0.25%，（忽略没有安全更新的浏览器，例如 ie10 和黑莓）。具体的配置方式可以参考 <a href="https://github.com/browserslist/browserslist#queries" target="_blank" rel="noopener noreferrer">browserslit<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的文档</p> <div class="language- extra-class"><pre class="language-text"><code>&gt; 0.25%
not dead
</code></pre></div><h3 id="options-配置"><a href="#options-配置" aria-hidden="true" class="header-anchor">#</a> Options 配置</h3> <p><strong><code>targets</code></strong></p> <p><code>string|Array&lt;string&gt;|{[string]:string}</code>,默认 <code>{}</code></p> <p>描述项目支持的浏览器环境</p> <p>可以是兼容 browserslist 的查询</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;targets&quot;</span><span class="token operator">:</span><span class="token string">&quot;&gt;0.25%,not dead&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也可以指定某种浏览器的最小版本支持</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;targets&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token property">&quot;chrome&quot;</span><span class="token operator">:</span><span class="token string">&quot;58&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;ie&quot;</span><span class="token operator">:</span><span class="token string">&quot;11&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果没有指定没有对应的 target，@babel/preset-env 默认将会转换<strong>所有</strong>的 <strong>ECMAScript2015+</strong> 的代码。</p> <blockquote><p>不推荐这样使用 preset-env，这样无法发挥出它指定浏览器转换的优势。特别是开启 polyfill 属性时，一定要指定这个 target 属性，否则引入的 polyfill 将会非常多</p></blockquote> <p>其他 targets 的配置</p> <ol><li><code>targets.esmodules</code>。 用来指定目标环境是否支持 es6 的模块机制，开启的话 browsers将会被忽略</li> <li><code>targets.node</code>。编译成 node 版本，可以选值<code>string|&quot;current&quot;|true</code></li> <li><code>targets.safari</code>。编译成 safari 的预览版本。</li> <li><code>targets.browsers</code>。<code>string|Array&lt;string&gt;</code>，使用 browerserslist 的查询语句，例如 <code>last 2 versions,&gt;5%,safari tp</code>。</li></ol> <p><strong><code>debug</code></strong></p> <p><code>boolean</code>，默认 <code>false</code></p> <p>输出使用的 targets/plugins 和 插件支持版本信息到控制台</p> <p><strong><code>useBuiltIns</code></strong></p> <ol><li>useBuiltIns:'usage'。不需要在 webpack.config.js 的任何入口或者代码引入 polyfill。将会自动分析用到的 API，然后在对应的文件自动引入。相当于自动的 require 或者 import</li> <li>useBuiltIns:'entry'。需要在源码的最顶部通过 import 或者 require 引入，类似上面的直接引入。多次引入会报错</li> <li>useBuiltIns:false。在 webpack.config.js 中，通过入口引入。如 module.exports = {entry:['@babel/polyfill','./app/js']}</li></ol> <p><strong><code>forceAllTransforms</code></strong></p> <p><code>boolean</code>，默认 <code>false</code></p> <p>默认情况下，这个预设将会运行目标环境所需要的所有转换。当输出需要通过 UglifyJs 或者一个完全只支持 ES5 的环境，这个选项将会很有用</p> <p><strong><code>configPath</code></strong></p> <p><code>string</code>，默认 <code>precess.cwd</code></p> <p>指定搜索 browserslist 的起始目录，会不停向上搜索直到根目录</p> <p><strong><code>shippedProposal</code></strong></p> <p><code>boolean</code>，默认 <code>false</code></p> <p>启动对于浏览器中内置特性的支持，例如目标浏览器支持一些比较新的语言特性，并且有着更好的表现，可以通过开启这个选项来避免进行代码进行转换。</p> <p><strong><code>ignoreBrowserslistConfig</code></strong></p> <p><code>boolean</code>，默认 <code>false</code></p> <p>是否忽略 browserslist 的配置。开启时不会检索 browserslist，</p> <p>另外还有 <code>spec</code>，<code>loose</code>，<code>include</code>，<code>exclude</code>。<code>include/exclude</code> 用来添加/移除某些插件。<code>loose</code> 编译时启用宽松模式，<code>spec</code> 启用更符合规范的编译。</p> <h2 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" aria-hidden="true" class="header-anchor">#</a> @babel/plugin-transform-runtime</h2> <p>这个插件做以下几件事情</p> <ol><li>若使用了 generators/async，自动引入 @babel/runtime/regenerator</li> <li>使用 corejs 这个选项时，自动从 corejs 引入相关帮助 API。例如使用了 Promise，那么就从 corejs 中引入 Promise 这个类，从而起到了 polyfill 的作用。本意是为了提供给 JS 包使用，使它们可以更自由的使用浏览器的内建 API，避免假设用户已经做了 polyfill 的情况。这个选项需要配和相关的 @babel/runtime-corejs包使用</li> <li>移除 babel 编译过程中内联的帮助函数，改成从 @babel/runtime/helps 从引入。从而减少生成的包的体积</li></ol> <h3 id="配置"><a href="#配置" aria-hidden="true" class="header-anchor">#</a> 配置</h3> <div class="language-json extra-class"><pre class="language-json"><code><span class="token comment">// 默认配置</span>
<span class="token punctuation">{</span>
	<span class="token property">&quot;plugins&quot;</span><span class="token operator">:</span><span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       <span class="token property">&quot;absouluteRuntime&quot;</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>
       <span class="token property">&quot;corejs&quot;</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token comment">//对应点 2</span>
       <span class="token property">&quot;helpers&quot;</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 对应点 3</span>
       <span class="token property">&quot;regenerator&quot;</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment">//对应点 1</span>
       <span class="token property">&quot;useESModules&quot;</span><span class="token operator">:</span><span class="token boolean">false</span> <span class="token comment">//是否开启 es6 模块，开启时 helpers 模块将以 es6 的形式导出，而不经过 @babel/plugin-transform-modules-commonjs</span>
     <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="corejs"><a href="#corejs" aria-hidden="true" class="header-anchor">#</a> corejs</h4> <p><code>boolean|number</code>，默认 <code>false</code></p> <p>指定 polyfill 的 corejs 版本。并且需要安装对应的 runtime-corejs 版本。如指定 corejs:3，那么就需要安装 @babel/runtime-corejs3。</p> <p>plugin-transform-runtime 的引入是不污染的全局的作用域，这是它 polyfill 的一个区别，并且它和 polyfill 理念是不一样的。polyfill 的想法是垫平环境的差异，因此需要根据环境差异来执行垫的操作，比如项目运行目标是运行在最新 chrome 上，那么它可能并不需要这个垫的操作。而 plugin-transform-runtime 是想提供一个可以自由使用内建 API 的环境给我们，使我们能毫无顾虑地使用这些内建 API，相当于一种全量引入。比如 Promise，那么就会自动从 core-js 中引入 Promise，相当于帮我们自动写了一条 require 语句。而且它并不会考虑目标环境，不管我们的目标环境是什么都会处理引入。在 corejs:2 选项中它能自动引入的帮助方法有限，可能无法识别引入 &quot;foobar&quot;.includes(&quot;foo&quot;) 这类实例方法，在使用 orejs:3 中好像没有这个问题。</p> <p>由于 plugin-transform-runtime 是按需提供一个 js 环境的，更适用于库和工具。而对于应用而言，它的目标环境明确，使用 useBuiltIns:&quot;usage&quot; 来处理更合适，能有效减少打包后的体积。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 转成</span>
<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> _promise <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;@babel/runtime-corejs2/core-js/promise&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//！注意此处 Promise 直接从 runtime-corejs2 中引入，而不是直接依赖于全局对象。</span>
<span class="token keyword">var</span> _promise2 <span class="token operator">=</span> <span class="token function">_interopRequireDefault</span><span class="token punctuation">(</span>_promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">_promise2<span class="token punctuation">.</span>default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这意味着我们可以无缝使用这些内建的原生方法和静态方法</span>
</code></pre></div><h4 id="helpers"><a href="#helpers" aria-hidden="true" class="header-anchor">#</a> helpers</h4> <p><code>boolean</code>，默认 <code>true</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 源码</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">//未开启 helpers</span>
<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//！这是重复定义项</span>
<span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> Constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Constructor</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Cannot call a class as a function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 开启 helpers</span>
<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token comment">//！classCallCheck 从 runtime/helpers 引入，减少了打包大小</span>
<span class="token keyword">var</span> _classCallCheck2 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;@babel/runtime/helpers/classCallCheck&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> _classCallCheck3 <span class="token operator">=</span> <span class="token function">_interopRequireDefault</span><span class="token punctuation">(</span>_classCallCheck2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">_interopRequireDefault</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>__esModule <span class="token operator">?</span> obj <span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> obj <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> _classCallCheck3<span class="token punctuation">.</span>default<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="babel-cli"><a href="#babel-cli" aria-hidden="true" class="header-anchor">#</a> @babel/cli</h2> <p>@babel/cli 自带了一个内置的 CLI 命令行工具，可以通过命令行来编译文件。此外各种能直接调用的脚本都存放在 @babel/cli/bin 中。主要有 babel-external-helpers.js 和 Babel cli 都主脚本 babel.js</p> <h3 id="用法"><a href="#用法" aria-hidden="true" class="header-anchor">#</a> 用法</h3> <p><code>babel main.js</code> 即编译 main.js 文件，<strong>支持目录</strong></p> <p><code>babel main.js -o lib.js</code> -o 或者 --out-file 输出到某个文件</p> <p><code>babel main.js --watch -o lib.js</code> -w 或者 --watch 监听文件修改，重新编译</p> <p><code>bable main.js -o lib.js --source-maps</code> --source-maps 用来输出 source-map</p> <p><code>babel src --out-dir lib</code> -d 或者 --out-dir 输出到某个目录</p> <h2 id="the-super-tiny-compiler"><a href="#the-super-tiny-compiler" aria-hidden="true" class="header-anchor">#</a> the super tiny compiler</h2> <p><a href="https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js" target="_blank" rel="noopener noreferrer">the super tiny compiler<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是一个小型的编译器，通过简化一些流程从而让我们更高效理解 Babel 是怎么工作的。整篇代码移除注释只不过 200 多行，非常适合于学习。</p> <p>大部分的编译程序工作流程分为以下三个步骤</p> <ol><li><strong>Parsing</strong>。把源码解析更加抽象的产物，例如中间代码或抽象语法输</li> <li><strong>Transformation</strong>。对于抽象产物进行操作</li> <li><strong>Code Generation</strong>.即最终代码生成</li></ol> <h3 id="parsing"><a href="#parsing" aria-hidden="true" class="header-anchor">#</a> Parsing</h3> <p>解析的过程分为两个步骤，词法分析和语法分析。</p> <p>词法分析的过程即对于源码进行切割，形成一个个 token。即 token 化。token 是一个对象数组，描述了一小段独立的语法片段，对象内描述可以是数字，标签，标点符号，操作符或者任意东西。</p> <p>语法分析的过程将 token 重新组成一个描述各个语法部分之间关系的对象。例如中间代码或者抽象语法树。抽象语法树即 ast，是一个包含着丰富信息，容易操作的，深层嵌套的对象。</p> <p>列如对于下列语法</p> <div class="language- extra-class"><pre class="language-text"><code>
(add 2 (subtract 4 2))

// token 化之后

[
     { type: 'paren',  value: '('        },
     { type: 'name',   value: 'add'      },
     { type: 'number', value: '2'        },
     { type: 'paren',  value: '('        },
     { type: 'name',   value: 'subtract' },
     { type: 'number', value: '4'        },
     { type: 'number', value: '2'        },
     { type: 'paren',  value: ')'        },
     { type: 'paren',  value: ')'        },
   ]

形成抽象语法树后

   {
     type: 'Program',
     body: [{
       type: 'CallExpression',
       name: 'add',
       params: [{
         type: 'NumberLiteral',
         value: '2',
       }, {
         type: 'CallExpression',
         name: 'subtract',
         params: [{
           type: 'NumberLiteral',
           value: '4',
         }, {
           type: 'NumberLiteral',
           value: '2',
         }]
       }]
     }]
   }
</code></pre></div><h3 id="示例代码"><a href="#示例代码" aria-hidden="true" class="header-anchor">#</a> 示例代码</h3> <p><strong>!TODO，加上自己的理解</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">tokenizer</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// A `current` variable for tracking our position in the code like a cursor.</span>
  <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// And a `tokens` array for pushing our tokens to.</span>
  <span class="token keyword">let</span> tokens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// We start by creating a `while` loop where we are setting up our `current`</span>
  <span class="token comment">// variable to be incremented as much as we want `inside` the loop.</span>
  <span class="token comment">//</span>
  <span class="token comment">// We do this because we may want to increment `current` many times within a</span>
  <span class="token comment">// single loop because our tokens can be any length.</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">&lt;</span> input<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// We're also going to store the `current` character in the `input`.</span>
    <span class="token keyword">let</span> char <span class="token operator">=</span> input<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// The first thing we want to check for is an open parenthesis. This will</span>
    <span class="token comment">// later be used for `CallExpression` but for now we only care about the</span>
    <span class="token comment">// character.</span>
    <span class="token comment">//</span>
    <span class="token comment">// We check to see if we have an open parenthesis:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>char <span class="token operator">===</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token comment">// If we do, we push a new token with the type `paren` and set the value</span>
      <span class="token comment">// to an open parenthesis.</span>
      tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token string">'paren'</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token string">'('</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Then we increment `current`</span>
      current<span class="token operator">++</span><span class="token punctuation">;</span>

      <span class="token comment">// And we `continue` onto the next cycle of the loop.</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Next we're going to check for a closing parenthesis. We do the same exact</span>
    <span class="token comment">// thing as before: Check for a closing parenthesis, add a new token,</span>
    <span class="token comment">// increment `current`, and `continue`.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>char <span class="token operator">===</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token string">'paren'</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token string">')'</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      current<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Moving on, we're now going to check for whitespace. This is interesting</span>
    <span class="token comment">// because we care that whitespace exists to separate characters, but it</span>
    <span class="token comment">// isn't actually important for us to store as a token. We would only throw</span>
    <span class="token comment">// it out later.</span>
    <span class="token comment">//</span>
    <span class="token comment">// So here we're just going to test for existence and if it does exist we're</span>
    <span class="token comment">// going to just `continue` on.</span>
    <span class="token keyword">let</span> <span class="token constant">WHITESPACE</span> <span class="token operator">=</span> <span class="token regex">/\s/</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">WHITESPACE</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      current<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// The next type of token is a number. This is different than what we have</span>
    <span class="token comment">// seen before because a number could be any number of characters and we</span>
    <span class="token comment">// want to capture the entire sequence of characters as one token.</span>
    <span class="token comment">//</span>
    <span class="token comment">//   (add 123 456)</span>
    <span class="token comment">//        ^^^ ^^^</span>
    <span class="token comment">//        Only two separate tokens</span>
    <span class="token comment">//</span>
    <span class="token comment">// So we start this off when we encounter the first number in a sequence.</span>
    <span class="token keyword">let</span> <span class="token constant">NUMBERS</span> <span class="token operator">=</span> <span class="token regex">/[0-9]/</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NUMBERS</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token comment">// We're going to create a `value` string that we are going to push</span>
      <span class="token comment">// characters to.</span>
      <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

      <span class="token comment">// Then we're going to loop through each character in the sequence until</span>
      <span class="token comment">// we encounter a character that is not a number, pushing each character</span>
      <span class="token comment">// that is a number to our `value` and incrementing `current` as we go.</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token constant">NUMBERS</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">+=</span> char<span class="token punctuation">;</span>
        char <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token operator">++</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// After that we push our `number` token to the `tokens` array.</span>
      tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'number'</span><span class="token punctuation">,</span> value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// And we continue on.</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// We'll also add support for strings in our language which will be any</span>
    <span class="token comment">// text surrounded by double quotes (&quot;).</span>
    <span class="token comment">//</span>
    <span class="token comment">//   (concat &quot;foo&quot; &quot;bar&quot;)</span>
    <span class="token comment">//            ^^^   ^^^ string tokens</span>
    <span class="token comment">//</span>
    <span class="token comment">// We'll start by checking for the opening quote:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>char <span class="token operator">===</span> <span class="token string">'&quot;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Keep a `value` variable for building up our string token.</span>
      <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

      <span class="token comment">// We'll skip the opening double quote in our token.</span>
      char <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token operator">++</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token comment">// Then we'll iterate through each character until we reach another</span>
      <span class="token comment">// double quote.</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>char <span class="token operator">!==</span> <span class="token string">'&quot;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">+=</span> char<span class="token punctuation">;</span>
        char <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token operator">++</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// Skip the closing double quote.</span>
      char <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token operator">++</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token comment">// And add our `string` token to the `tokens` array.</span>
      tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">,</span> value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// The last type of token will be a `name` token. This is a sequence of</span>
    <span class="token comment">// letters instead of numbers, that are the names of functions in our lisp</span>
    <span class="token comment">// syntax.</span>
    <span class="token comment">//</span>
    <span class="token comment">//   (add 2 4)</span>
    <span class="token comment">//    ^^^</span>
    <span class="token comment">//    Name token</span>
    <span class="token comment">//</span>
    <span class="token keyword">let</span> <span class="token constant">LETTERS</span> <span class="token operator">=</span> <span class="token regex">/[a-z]/i</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">LETTERS</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

      <span class="token comment">// Again we're just going to loop through all the letters pushing them to</span>
      <span class="token comment">// a value.</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token constant">LETTERS</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">+=</span> char<span class="token punctuation">;</span>
        char <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token operator">++</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// And pushing that value as a token with the type `name` and continuing.</span>
      tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'name'</span><span class="token punctuation">,</span> value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Finally if we have not matched a character by now, we're going to throw</span>
    <span class="token comment">// an error and completely exit.</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'I dont know what this character is: '</span> <span class="token operator">+</span> char<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Then at the end of our `tokenizer` we simply return the tokens array.</span>
  <span class="token keyword">return</span> tokens<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * ============================================================================
 *                                 ヽ/❀o ل͜ o\ﾉ
 *                                THE PARSER!!!
 * ============================================================================
 */</span>

<span class="token comment">/**
 * For our parser we're going to take our array of tokens and turn it into an
 * AST.
 *
 *   [{ type: 'paren', value: '(' }, ...]   =&gt;   { type: 'Program', body: [...] }
 */</span>

<span class="token comment">// Okay, so we define a `parser` function that accepts our array of `tokens`.</span>
<span class="token keyword">function</span> <span class="token function">parser</span><span class="token punctuation">(</span><span class="token parameter">tokens</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// Again we keep a `current` variable that we will use as a cursor.</span>
  <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// But this time we're going to use recursion instead of a `while` loop. So we</span>
  <span class="token comment">// define a `walk` function.</span>
  <span class="token keyword">function</span> <span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// Inside the walk function we start by grabbing the `current` token.</span>
    <span class="token keyword">let</span> token <span class="token operator">=</span> tokens<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// We're going to split each type of token off into a different code path,</span>
    <span class="token comment">// starting off with `number` tokens.</span>
    <span class="token comment">//</span>
    <span class="token comment">// We test to see if we have a `number` token.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token comment">// If we have one, we'll increment `current`.</span>
      current<span class="token operator">++</span><span class="token punctuation">;</span>

      <span class="token comment">// And we'll return a new AST node called `NumberLiteral` and setting its</span>
      <span class="token comment">// value to the value of our token.</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token string">'NumberLiteral'</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> token<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// If we have a string we will do the same as number and create a</span>
    <span class="token comment">// `StringLiteral` node.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      current<span class="token operator">++</span><span class="token punctuation">;</span>

      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> token<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Next we're going to look for CallExpressions. We start this off when we</span>
    <span class="token comment">// encounter an open parenthesis.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      token<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'paren'</span> <span class="token operator">&amp;&amp;</span>
      token<span class="token punctuation">.</span>value <span class="token operator">===</span> <span class="token string">'('</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token comment">// We'll increment `current` to skip the parenthesis since we don't care</span>
      <span class="token comment">// about it in our AST.</span>
      token <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token operator">++</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token comment">// We create a base node with the type `CallExpression`, and we're going</span>
      <span class="token comment">// to set the name as the current token's value since the next token after</span>
      <span class="token comment">// the open parenthesis is the name of the function.</span>
      <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token string">'CallExpression'</span><span class="token punctuation">,</span>
        name<span class="token punctuation">:</span> token<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
        params<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>

      <span class="token comment">// We increment `current` *again* to skip the name token.</span>
      token <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token operator">++</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token comment">// And now we want to loop through each token that will be the `params` of</span>
      <span class="token comment">// our `CallExpression` until we encounter a closing parenthesis.</span>
      <span class="token comment">//</span>
      <span class="token comment">// Now this is where recursion comes in. Instead of trying to parse a</span>
      <span class="token comment">// potentially infinitely nested set of nodes we're going to rely on</span>
      <span class="token comment">// recursion to resolve things.</span>
      <span class="token comment">//</span>
      <span class="token comment">// To explain this, let's take our Lisp code. You can see that the</span>
      <span class="token comment">// parameters of the `add` are a number and a nested `CallExpression` that</span>
      <span class="token comment">// includes its own numbers.</span>
      <span class="token comment">//</span>
      <span class="token comment">//   (add 2 (subtract 4 2))</span>
      <span class="token comment">//</span>
      <span class="token comment">// You'll also notice that in our tokens array we have multiple closing</span>
      <span class="token comment">// parenthesis.</span>
      <span class="token comment">//</span>
      <span class="token comment">//   [</span>
      <span class="token comment">//     { type: 'paren',  value: '('        },</span>
      <span class="token comment">//     { type: 'name',   value: 'add'      },</span>
      <span class="token comment">//     { type: 'number', value: '2'        },</span>
      <span class="token comment">//     { type: 'paren',  value: '('        },</span>
      <span class="token comment">//     { type: 'name',   value: 'subtract' },</span>
      <span class="token comment">//     { type: 'number', value: '4'        },</span>
      <span class="token comment">//     { type: 'number', value: '2'        },</span>
      <span class="token comment">//     { type: 'paren',  value: ')'        }, &lt;&lt;&lt; Closing parenthesis</span>
      <span class="token comment">//     { type: 'paren',  value: ')'        }, &lt;&lt;&lt; Closing parenthesis</span>
      <span class="token comment">//   ]</span>
      <span class="token comment">//</span>
      <span class="token comment">// We're going to rely on the nested `walk` function to increment our</span>
      <span class="token comment">// `current` variable past any nested `CallExpression`.</span>

      <span class="token comment">// So we create a `while` loop that will continue until it encounters a</span>
      <span class="token comment">// token with a `type` of `'paren'` and a `value` of a closing</span>
      <span class="token comment">// parenthesis.</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>
        <span class="token punctuation">(</span>token<span class="token punctuation">.</span>type <span class="token operator">!==</span> <span class="token string">'paren'</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>token<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'paren'</span> <span class="token operator">&amp;&amp;</span> token<span class="token punctuation">.</span>value <span class="token operator">!==</span> <span class="token string">')'</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// we'll call the `walk` function which will return a `node` and we'll</span>
        <span class="token comment">// push it into our `node.params`.</span>
        node<span class="token punctuation">.</span>params<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        token <span class="token operator">=</span> tokens<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// Finally we will increment `current` one last time to skip the closing</span>
      <span class="token comment">// parenthesis.</span>
      current<span class="token operator">++</span><span class="token punctuation">;</span>

      <span class="token comment">// And return the node.</span>
      <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Again, if we haven't recognized the token type by now we're going to</span>
    <span class="token comment">// throw an error.</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>token<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Now, we're going to create our AST which will have a root which is a</span>
  <span class="token comment">// `Program` node.</span>
  <span class="token keyword">let</span> ast <span class="token operator">=</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> <span class="token string">'Program'</span><span class="token punctuation">,</span>
    body<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// And we're going to kickstart our `walk` function, pushing nodes to our</span>
  <span class="token comment">// `ast.body` array.</span>
  <span class="token comment">//</span>
  <span class="token comment">// The reason we are doing this inside a loop is because our program can have</span>
  <span class="token comment">// `CallExpression` after one another instead of being nested.</span>
  <span class="token comment">//</span>
  <span class="token comment">//   (add 2 2)</span>
  <span class="token comment">//   (subtract 4 2)</span>
  <span class="token comment">//</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ast<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// At the end of our parser we'll return the AST.</span>
  <span class="token keyword">return</span> ast<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * ============================================================================
 *                                 ⌒(❀&gt;◞౪◟&lt;❀)⌒
 *                               THE TRAVERSER!!!
 * ============================================================================
 */</span>

<span class="token comment">/**
 * So now we have our AST, and we want to be able to visit different nodes with
 * a visitor. We need to be able to call the methods on the visitor whenever we
 * encounter a node with a matching type.
 *
 *   traverse(ast, {
 *     Program: {
 *       enter(node, parent) {
 *         // ...
 *       },
 *       exit(node, parent) {
 *         // ...
 *       },
 *     },
 *
 *     CallExpression: {
 *       enter(node, parent) {
 *         // ...
 *       },
 *       exit(node, parent) {
 *         // ...
 *       },
 *     },
 *
 *     NumberLiteral: {
 *       enter(node, parent) {
 *         // ...
 *       },
 *       exit(node, parent) {
 *         // ...
 *       },
 *     },
 *   });
 */</span>

<span class="token comment">// So we define a traverser function which accepts an AST and a</span>
<span class="token comment">// visitor. Inside we're going to define two functions...</span>
<span class="token keyword">function</span> <span class="token function">traverser</span><span class="token punctuation">(</span><span class="token parameter">ast<span class="token punctuation">,</span> visitor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// A `traverseArray` function that will allow us to iterate over an array and</span>
  <span class="token comment">// call the next function that we will define: `traverseNode`.</span>
  <span class="token keyword">function</span> <span class="token function">traverseArray</span><span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">traverseNode</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// `traverseNode` will accept a `node` and its `parent` node. So that it can</span>
  <span class="token comment">// pass both to our visitor methods.</span>
  <span class="token keyword">function</span> <span class="token function">traverseNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// We start by testing for the existence of a method on the visitor with a</span>
    <span class="token comment">// matching `type`.</span>
    <span class="token keyword">let</span> methods <span class="token operator">=</span> visitor<span class="token punctuation">[</span>node<span class="token punctuation">.</span>type<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// If there is an `enter` method for this node type we'll call it with the</span>
    <span class="token comment">// `node` and its `parent`.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> methods<span class="token punctuation">.</span>enter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      methods<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Next we are going to split things up by the current node type.</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token comment">// We'll start with our top level `Program`. Since Program nodes have a</span>
      <span class="token comment">// property named body that has an array of nodes, we will call</span>
      <span class="token comment">// `traverseArray` to traverse down into them.</span>
      <span class="token comment">//</span>
      <span class="token comment">// (Remember that `traverseArray` will in turn call `traverseNode` so  we</span>
      <span class="token comment">// are causing the tree to be traversed recursively)</span>
      <span class="token keyword">case</span> <span class="token string">'Program'</span><span class="token punctuation">:</span>
        <span class="token function">traverseArray</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>body<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>

      <span class="token comment">// Next we do the same with `CallExpression` and traverse their `params`.</span>
      <span class="token keyword">case</span> <span class="token string">'CallExpression'</span><span class="token punctuation">:</span>
        <span class="token function">traverseArray</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>params<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>

      <span class="token comment">// In the cases of `NumberLiteral` and `StringLiteral` we don't have any</span>
      <span class="token comment">// child nodes to visit, so we'll just break.</span>
      <span class="token keyword">case</span> <span class="token string">'NumberLiteral'</span><span class="token punctuation">:</span>
      <span class="token keyword">case</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>

      <span class="token comment">// And again, if we haven't recognized the node type then we'll throw an</span>
      <span class="token comment">// error.</span>
      <span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// If there is an `exit` method for this node type we'll call it with the</span>
    <span class="token comment">// `node` and its `parent`.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> methods<span class="token punctuation">.</span>exit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      methods<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Finally we kickstart the traverser by calling `traverseNode` with our ast</span>
  <span class="token comment">// with no `parent` because the top level of the AST doesn't have a parent.</span>
  <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * ============================================================================
 *                                   ⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽
 *                              THE TRANSFORMER!!!
 * ============================================================================
 */</span>

<span class="token comment">/**
 * Next up, the transformer. Our transformer is going to take the AST that we
 * have built and pass it to our traverser function with a visitor and will
 * create a new ast.
 *
 * ----------------------------------------------------------------------------
 *   Original AST                     |   Transformed AST
 * ----------------------------------------------------------------------------
 *   {                                |   {
 *     type: 'Program',               |     type: 'Program',
 *     body: [{                       |     body: [{
 *       type: 'CallExpression',      |       type: 'ExpressionStatement',
 *       name: 'add',                 |       expression: {
 *       params: [{                   |         type: 'CallExpression',
 *         type: 'NumberLiteral',     |         callee: {
 *         value: '2'                 |           type: 'Identifier',
 *       }, {                         |           name: 'add'
 *         type: 'CallExpression',    |         },
 *         name: 'subtract',          |         arguments: [{
 *         params: [{                 |           type: 'NumberLiteral',
 *           type: 'NumberLiteral',   |           value: '2'
 *           value: '4'               |         }, {
 *         }, {                       |           type: 'CallExpression',
 *           type: 'NumberLiteral',   |           callee: {
 *           value: '2'               |             type: 'Identifier',
 *         }]                         |             name: 'subtract'
 *       }]                           |           },
 *     }]                             |           arguments: [{
 *   }                                |             type: 'NumberLiteral',
 *                                    |             value: '4'
 * ---------------------------------- |           }, {
 *                                    |             type: 'NumberLiteral',
 *                                    |             value: '2'
 *                                    |           }]
 *  (sorry the other one is longer.)  |         }
 *                                    |       }
 *                                    |     }]
 *                                    |   }
 * ----------------------------------------------------------------------------
 */</span>

<span class="token comment">// So we have our transformer function which will accept the lisp ast.</span>
<span class="token keyword">function</span> <span class="token function">transformer</span><span class="token punctuation">(</span><span class="token parameter">ast</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// We'll create a `newAst` which like our previous AST will have a program</span>
  <span class="token comment">// node.</span>
  <span class="token keyword">let</span> newAst <span class="token operator">=</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> <span class="token string">'Program'</span><span class="token punctuation">,</span>
    body<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// Next I'm going to cheat a little and create a bit of a hack. We're going to</span>
  <span class="token comment">// use a property named `context` on our parent nodes that we're going to push</span>
  <span class="token comment">// nodes to their parent's `context`. Normally you would have a better</span>
  <span class="token comment">// abstraction than this, but for our purposes this keeps things simple.</span>
  <span class="token comment">//</span>
  <span class="token comment">// Just take note that the context is a reference *from* the old ast *to* the</span>
  <span class="token comment">// new ast.</span>
  ast<span class="token punctuation">.</span>_context <span class="token operator">=</span> newAst<span class="token punctuation">.</span>body<span class="token punctuation">;</span>

  <span class="token comment">// We'll start by calling the traverser function with our ast and a visitor.</span>
  <span class="token function">traverser</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>

    <span class="token comment">// The first visitor method accepts any `NumberLiteral`</span>
    NumberLiteral<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// We'll visit them on enter.</span>
      <span class="token function">enter</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// We'll create a new node also named `NumberLiteral` that we will push to</span>
        <span class="token comment">// the parent context.</span>
        parent<span class="token punctuation">.</span>_context<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          type<span class="token punctuation">:</span> <span class="token string">'NumberLiteral'</span><span class="token punctuation">,</span>
          value<span class="token punctuation">:</span> node<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token comment">// Next we have `StringLiteral`</span>
    StringLiteral<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token function">enter</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent<span class="token punctuation">.</span>_context<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          type<span class="token punctuation">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span>
          value<span class="token punctuation">:</span> node<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token comment">// Next up, `CallExpression`.</span>
    CallExpression<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token function">enter</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// We start creating a new node `CallExpression` with a nested</span>
        <span class="token comment">// `Identifier`.</span>
        <span class="token keyword">let</span> expression <span class="token operator">=</span> <span class="token punctuation">{</span>
          type<span class="token punctuation">:</span> <span class="token string">'CallExpression'</span><span class="token punctuation">,</span>
          callee<span class="token punctuation">:</span> <span class="token punctuation">{</span>
            type<span class="token punctuation">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span>
            name<span class="token punctuation">:</span> node<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          arguments<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// Next we're going to define a new context on the original</span>
        <span class="token comment">// `CallExpression` node that will reference the `expression`'s arguments</span>
        <span class="token comment">// so that we can push arguments.</span>
        node<span class="token punctuation">.</span>_context <span class="token operator">=</span> expression<span class="token punctuation">.</span>arguments<span class="token punctuation">;</span>

        <span class="token comment">// Then we're going to check if the parent node is a `CallExpression`.</span>
        <span class="token comment">// If it is not...</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>type <span class="token operator">!==</span> <span class="token string">'CallExpression'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

          <span class="token comment">// We're going to wrap our `CallExpression` node with an</span>
          <span class="token comment">// `ExpressionStatement`. We do this because the top level</span>
          <span class="token comment">// `CallExpression` in JavaScript are actually statements.</span>
          expression <span class="token operator">=</span> <span class="token punctuation">{</span>
            type<span class="token punctuation">:</span> <span class="token string">'ExpressionStatement'</span><span class="token punctuation">,</span>
            expression<span class="token punctuation">:</span> expression<span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Last, we push our (possibly wrapped) `CallExpression` to the `parent`'s</span>
        <span class="token comment">// `context`.</span>
        parent<span class="token punctuation">.</span>_context<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// At the end of our transformer function we'll return the new ast that we</span>
  <span class="token comment">// just created.</span>
  <span class="token keyword">return</span> newAst<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * ============================================================================
 *                               ヾ（〃＾∇＾）ﾉ♪
 *                            THE CODE GENERATOR!!!!
 * ============================================================================
 */</span>

<span class="token comment">/**
 * Now let's move onto our last phase: The Code Generator.
 *
 * Our code generator is going to recursively call itself to print each node in
 * the tree into one giant string.
 */</span>

<span class="token keyword">function</span> <span class="token function">codeGenerator</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// We'll break things down by the `type` of the `node`.</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// If we have a `Program` node. We will map through each node in the `body`</span>
    <span class="token comment">// and run them through the code generator and join them with a newline.</span>
    <span class="token keyword">case</span> <span class="token string">'Program'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>codeGenerator<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// For `ExpressionStatement` we'll call the code generator on the nested</span>
    <span class="token comment">// expression and we'll add a semicolon...</span>
    <span class="token keyword">case</span> <span class="token string">'ExpressionStatement'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token function">codeGenerator</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>expression<span class="token punctuation">)</span> <span class="token operator">+</span>
        <span class="token string">';'</span> <span class="token comment">// &lt;&lt; (...because we like to code the *correct* way)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// For `CallExpression` we will print the `callee`, add an open</span>
    <span class="token comment">// parenthesis, we'll map through each node in the `arguments` array and run</span>
    <span class="token comment">// them through the code generator, joining them with a comma, and then</span>
    <span class="token comment">// we'll add a closing parenthesis.</span>
    <span class="token keyword">case</span> <span class="token string">'CallExpression'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token function">codeGenerator</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>callee<span class="token punctuation">)</span> <span class="token operator">+</span>
        <span class="token string">'('</span> <span class="token operator">+</span>
        node<span class="token punctuation">.</span>arguments<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>codeGenerator<span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">', '</span><span class="token punctuation">)</span> <span class="token operator">+</span>
        <span class="token string">')'</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// For `Identifier` we'll just return the `node`'s name.</span>
    <span class="token keyword">case</span> <span class="token string">'Identifier'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span>name<span class="token punctuation">;</span>

    <span class="token comment">// For `NumberLiteral` we'll just return the `node`'s value.</span>
    <span class="token keyword">case</span> <span class="token string">'NumberLiteral'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>

    <span class="token comment">// For `StringLiteral` we'll add quotations around the `node`'s value.</span>
    <span class="token keyword">case</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token string">'&quot;'</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">'&quot;'</span><span class="token punctuation">;</span>

    <span class="token comment">// And if we haven't recognized the node, we'll throw an error.</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * ============================================================================
 *                                  (۶* ‘ヮ’)۶”
 *                         !!!!!!!!THE COMPILER!!!!!!!!
 * ============================================================================
 */</span>

<span class="token comment">/**
 * FINALLY! We'll create our `compiler` function. Here we will link together
 * every part of the pipeline.
 *
 *   1. input  =&gt; tokenizer   =&gt; tokens
 *   2. tokens =&gt; parser      =&gt; ast
 *   3. ast    =&gt; transformer =&gt; newAst
 *   4. newAst =&gt; generator   =&gt; output
 */</span>

<span class="token keyword">function</span> <span class="token function">compiler</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> tokens <span class="token operator">=</span> <span class="token function">tokenizer</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> ast    <span class="token operator">=</span> <span class="token function">parser</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> newAst <span class="token operator">=</span> <span class="token function">transformer</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> output <span class="token operator">=</span> <span class="token function">codeGenerator</span><span class="token punctuation">(</span>newAst<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// and simply return the output!</span>
  <span class="token keyword">return</span> output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * ============================================================================
 *                                   (๑˃̵ᴗ˂̵)و
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!YOU MADE IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * ============================================================================
 */</span>

<span class="token comment">// Now I'm just exporting everything...</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  tokenizer<span class="token punctuation">,</span>
  parser<span class="token punctuation">,</span>
  traverser<span class="token punctuation">,</span>
  transformer<span class="token punctuation">,</span>
  codeGenerator<span class="token punctuation">,</span>
  compiler<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ccbd119b.js" defer></script><script src="/assets/js/2.7f0dc0b6.js" defer></script><script src="/assets/js/8.890852ad.js" defer></script>
  </body>
</html>
